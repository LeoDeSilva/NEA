\subsection{Objectives}
\begin{longtable}{ | p{2cm} | p{4cm} | p{5cm} | p{4cm} | } 
    \hline
        Objective & Requirement & Justification & Deliverables \\ 
    \hline
        1.0 ISA \& Assembler & & & \\ 
    \hline
        1.1
        & 
        A RISC (Reduced Instruction Set Computer) design philosophy. 
        &
        A RISC instruction set can have better performance due to the faster and more efficient execution of it's instructions, especially when a user isn't as familiar with the instruction set of the system. (Client Interview 1.1) 
        & 
        \\
  \hline
        1.2 
        & 
        A Von Neuman computer architecture where both data and instructions share the same memory. 
        & 
        The shared memory between data and instructions minimises memory wastage since they can both share the same memory locations. (University of Washington MIPS Computer 1.) 
        & 
        \\
  \hline
        1.3 
        &  
        My Instruction Set should utilize 3 address operands standards.
        & 
        3 address operands is the programming standard for both arm and x86, pre-established instruction sets programemrs are already familiar with. The need to address instruction and data from different memories in a Harvard architecture is typically hidden from the programmer. (Client Interview 1.2)
        & 
        Assembly instructions should take 3 operands: a destination register followed by 1-2 source registers. Programmers should interface with the branch and load instructions in the same manner when addressing instructions or data.
        \\
  \hline
        1.4 
        & 
        Branch and call instructions should calculate offsets from labels in the source code. 
        & 
        Labels allow programmers to write branching or selective statements without having to manually calculate memory offests. (The Hack Computer, The University of Washington MIPS Computer, Client Interview) 
        & 
        My assembler should replace all occurences of a label in the assembly source code with calculated offests from the current instruction to that label.
        \\
  \hline
        1.5 
        & 
        Macro instructions to perform common tasks that are not otherwise specified in the ISA. 
        &
        Macro instructions minimise the need for programmers to repeat chunks of code to perform common tasks such as pushing values to the stack or calling functions. (The Hack Computer 2., Client Interview) 
        & 
        The assembler should substitute compound instructions such as \texttt{call} and \texttt{ret} for a list of machine code instructions that perform the same task.
        \\
    \hline
        1.6 
        & 
        A set of registers broad enough to minimse memory access. 
        &
        Prioritising registers over RAM improves processor performance as calculations can be performed with reduced latency. A delay timer simplifies the process of timing CPU operations, and a memory-resident address stack simplifies the process of calling and returning from functions. (Austin Moorlan's CHIP-8 Emulator, Client Interview 1.3)
        & 
        My processor should have 16 general purpose registers (r0-rF), a stack pointer (SP), program counter (PC), and delay timer (DT).
        \\
    \hline
        1.7 & 
        A CPU word length of 16-bits. &
        A 16-bit word length allow more bits to be processed in a single cycle and allows 16-bit instructions to be fetched within a single cycle improving performance. 16-bits can also represent numbers of a greater magnitude than 8-bits reducing overflow errors. (Client Interview 1.4) &
        Registers, ALU operations, memory locations and busses should all operate on 16-bit values.\\
    \hline
        2.0 Compiler & 
        &
        & 
       \\
    \hline
        2.1 & 
        C standard syntax with semi colons and braces rather than indentation. &
        This makes for easier compilation and more flexibility when formatting code, as well as reporting errors such as an unterminated brace at compile time (unlike incorrect indentation which may not be detected until debugging) (Client Interview 2.2) & 
        Lines should be terminated using a semi-colon, and curly-braces used to signify code blocks in selective or iterative expressions rather than indentation.\\
    \hline
        2.2 & 
        The programming language should be statically typed. &
        A type system ensures type-errors are thrown at compile time rather than during execution, leading to more robust programs that are easier to debug. Furthermore compilation becomes easier with statically typed variables as their size in memory is predetermined. (Monkey.2, Jack.4, Client Interview 2.5) & 
        My syntax should support signed and unsigned integers, characters, booleans. The \texttt{let} keyword should be used when declaring a variable and require the type to be specified alongside its identifier. \\
    \hline
        2.3 & 
        The language should support a procedural programming paradigm. &
        Procedural programming is much more straightforward to compile since variable lifetimes within multiple instances and references of an object don't have to be calculated - simplifying the process of garbage collection. (Client Interview 2.1, Jack.1) & 
        All statements should be contained within methods, with the single entry point being a compulsory \texttt{main()} method. \\
    \hline
        2.4 & 
        My language should support references and pointers to variables in memory. & 
        Pointers allow programmers to implement arrays and strings by accessing variables through their memory location rather than an identifier. They also let you pass structs (otherwise a large data structure inefficient to pass as a copy) to a function as well as references to the first instruction of a function (allowing for first order functions) (Monkey.3)& 
        Programmers should be able to create a pointer to a variable: (\texttt{\&a}), and dereference it (\texttt{*a}). \\
    \hline
        2.5 & 
        The compiler should produce relevant error messages, pointing out the position in source code if relevant. &
        Relevant error messages make debugging much easier and improve the programmer's experience with a language. (Client Interview 2.4) &
        Error messages should include an easy to understand description of the error, its position in source code - and if possible, relevant steps to correcting it.
        \\
    \hline
        2.6 & 
        The language should support definite and indefinite iteration through for and while loops. &
        Iteration is a key element of control flow for a procedural language. &
        'for' and 'while' keywords should be used for the two different types of loops. 
        \\
    \hline
        2.7 & 
        Data should be stored in scoped variables and global constants. & 
        Storing data in scoped variables ensures memory is efficiently managed, preventing unintended side effects from modifying global variables. Constants help improve code readability and make debugging easier. & 
        The 'let' keyword should be used to declare variables inside a subroutine, and 'const' for declaring gloabl constants. 
        \\
    \hline
        2.8 & 
        The compiler should support defining and calling functions. &
        Functions allow code to be reused, and encapsulate logic into distinct units. Furthermore, functions help with code organisation. &
        Programmers should be able to declare functions with typed parameters and a return type. Functions should support recursion.
        \\
    \hline
        3.0 Virtual Machine & 
        &
        & 
       \\
    \hline
        3.1 & 
        The Virtual Machine should include a graphical display showing the contents of VRAM. &
        It makes programs more interactive and easily debuggable, as well as allowing programs such as simulations or games to be written for the system, expanding its capabilties. (Austin Morlan's CHIP-8 Emulator) & 
        \\
    \hline
        3.2 & 
        The Virtual Machine should include a togglable debugger. &
        A debugger would help programmers locate errors and test their programs, as well as ensuring the internal state of the computer is being modified as intended. (Client Interview 3.1, Austin Morlan's CHIP-8 Emulator.2) & 
        The debugger should show the contents of the general and special purpose registers, the currently executing instruction, and be able to probe the contents of memory. \\
    \hline
\end{longtable}