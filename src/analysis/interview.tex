\subsubsection{Client Interview}
\label{sec:Interview}
I will interview my client to get his views on a number of questions regarding the design of my project, including the processor design and instruction set; the assembly language syntax and   machine code abstractions (macros and labels); and finally the higher level language syntax and features (OOP, first order functions, etc...).  
\begin{enumerate}
    \item \textbf{Instruction Set Architecture \& Assembler}
        \begin{itemize}
            \item Q: Do you have any low level experience? \\
                RFA: To determine my clients level of familiarity with my problem domain, and to target my questions towards that.\\
                A: \textit{"I used assembly when writing a driver a few years back, but I've not gone much lower level than that. Although I can remember some theory from University."}
            \item FU: What architecture did you use, and what were your experiences using it? \\
                RFA: To establish whether my client has used a RISC or a CISC architecture and inform any follow up questions that would help determine which architecture my project will use. \\
                A: \textit{"I was migrating a driver in x86 to ARM so I've touched on both. x86 is definitely more powerful, but that does mean it's harder to learn because there's so many more instructions. Although once you do know it, it's really efficient to program in, and you can write complex programs relatively concisely. ARM is the opposite, its easy to understand with an obviously well thought out design that makes it nice to program in whether you're just learning or experienced."}
            \item FU: Did you prefer working with a CISC (x86) or RISC (arm) Instruction Set? \\
                RFA: To inform whether I use a RISC or CISC architecture.\\
                A: \textit{"I prefer RISC because the fewer instructions mean those that are present tend to be much more carefully thought out, it's also just generally easier to program without flipping back to the documentation every 5 minutes."}
            \item Q: Have you ever programmed for a Harvard architecture computer? \\
                RFA: I want to determine whether my client is opposed to or in favour of programming for such a system.\\
                A: \textit{"Most ARM processor tend to run on a Harvard architecture, although the assembly language hides that level of hardware anyway so it's not something I really have to consider."}
            \item Q: What in particular did you like about the syntax of x86 or arm assembly?\\
                RFA: To determine what he is familiar with and thus help design the syntax of my assembly language. \\
                A: \textit{"They're both quite similar aside from their register names. x86 uses eax, ebx - but arm uses r0, r1.  Which I think makes more sense. I think x86 has longer menumonics as well - although that's probably because of its larger instruction set."}
            \item FU: When writing assembly do you find yourself using labels or macro instructions?\\
                RFA: To see if my client wants me to include these higher level assembly language features in my assembler.\\
                A: \textit{"Labels are really important when coding, and they mean you don't have to keep recalculating offsets every time you add a new instruction. But for a RISC processor like arm - macro instructions provided by the assembler can be really helpful - they cut out a lot of the tedious programming when you write the same thing over and over."}
            \item Q: Would you prefer to write assembly for a 16-bit or an 8-bit system? \\
                RFA: To understand my client's position on the impact of the word-length of a system.\\
                A: \textit{"I would prefer a 16-bit system because of the flexibility in representing large or precise numbers which you just can't do with an 8-bit system. It lets you worry less about overflow and underflow and all the quirks of binary maths."}
        \end{itemize}
        Takeaways:
        \begin{enumerate}
            \item My client favours a RISC instruction set, particularly the carefully considered instructions. I should take time when designing my instruction set to ensure there is enough breadth to cover all the desired functionality in an effective manner that is convenient to program in.
            \item My assembly language's instructions should abstract away the quirks of the Harvard architecture's seperate data and instruction memories - meaning my client will have more transferable experience when programming in my langauge.
            \item Registers should be named logically, either  alphabetically or numerically, e.g. 'r0, r1, r2, ...' or 'a, b, c, ...'.
            \item My client would prefer a 16-bit system.
        \end{enumerate}
    \item \textbf{Compiler \& High Level Language}
        \begin{itemize}
            \item Q: When you write code, do you prefer an Object Oriented or Procedural Style? \\
                RFA: To decide whether my language needs an OOP focus like Java, or a procedural approach.?\\
                A: \textit{"I like the flexibility of procedural programming, even though I tend to write cleaner code when I use OOP, I think procedural is easier to pick up and code. You could do something like python where you support OOP but don't enforce it?"}
            \item Q: Do you prefer a simpler syntax like python, or something more like C? \\
                RFA: To determine which syntax style my language should use.\\
                A: \textit{"I've been coding in Go for work and I like their approach. It's got the unambigious syntax of C with the flexibility in how you format your code that comes with braces and semicolons, but they've also simplified the type system so you don't have to think about integer sizes or pointers in strings."}
            \item FU: Would you like my language to have a simlar syntax to preexisting langauges, or to try something new? \\
                RFA: To see how important familiarity is to my client, and whether he'd be willing to try new ideas to see if they work.\\
                \textit{"I think it's important a language is readable to someone with no experience programming in it, so I wouldn't change the format too much. But it's nice to try some new things, like what go did with goroutines, or rust with the borrow checker."}
            \item Q: If you could design your own language, what features would be most important to you? \\
                RFA: To allow my client to suggest other ideas I hadn't considered that might aid the design of my language. \\
                A: \textit{"I think good error messages go a long way into improving my experience with a language. They're often overlooked when you're writing a language, but for someone just learning how to code, they're make or break. I'd also say a good type system, Go and Java have pretty good approaches, although when you're writing something lower level you need that extra information about the size of your variables they just don't offer. What Rust does with it's numeric types is good, although I think their approach to strings needs refining."}
        \end{itemize}
        Takeaways:
        \begin{enumerate}
            \item My language should be a primarily procedural langauge, however offer optional elements of object oriented programming such as classes and interfaces to help organise programs.
            \item My programming language should use the C like syntax elements of curly braces and semi colons as they offer more flexibility when formatting code. 
            \item Without straying too far from the norms, I should consider alternative aproaches to syntax and langage features in order to differentiate my language, aggregating positive elements of other systems.
            \item My compiler should produce specific and actable error messages that are actually helpful to a programmer. This may include information on how to approach correcting such an error and its location in the source code. 
            \item A strong type system is important, It should abstract the implementation details of compound data structures such as strings, however still offer the flexibility required when writing lower level programs. For example specifying an integer size or whether it is signed or unsigned.
        \end{enumerate}
    \item \textbf{Virtual Machine}
        \begin{itemize}
            \item Q: Have you ever used a Virtual Machine before? \\
                RFA: To see in how much detail I can ask the follow-up questions.\\
                A: \textit{"I've used a Gameboy emulator before, but I've never coded anything in one."}
            \item Q: What features would you expect if you were using a virtual machine to test your code? \\
                RFA: To see which features are the most vital to include in my emulator in order to help my client code for my computer.\\
                A: \textit{"I think a good debugger is important, certainly one showing the contents of RAM, register values, and the current instruction being executed. With maybe the ability to step through a program one instruction at a time setting breakpoints."}
        \end{itemize}
        Takeaways:
        \begin{enumerate}
            \item My virtual machine should include a comprehensive debugger for testing programs, you should be able to check the internal state of the computers memory and registers to determine whether the program is functioning as intended.
        \end{enumerate}
\end{enumerate}

This interview has affirmed that the direction in which to take my project is that of a simpler RISC processor with carefully considered instructions, relying more on macro instructions provided by the assembler to improve the development experience rather than on the hardware itself. My client also suggested a procedural language structure with syntax similar to C, a common trend with lower level languages. He also emphasised the importance of a well considered type system and error messages, so these should have careful consideration in my design section. Finally, due to the difficulty of testing machine code programs, a debugging mode in the virtual machine would greatly improve the experience of my client when writing assembly code.